https://www.baeldung.com/java-switch            **** A switch works only with four primitives and their wrappers, as well as with the enum type and the String class:
https://www.geeksforgeeks.org/decision-making-javaif-else-switch-break-continue-jump/
https://devqa.io/java-if-else-switch-statements/

--------------------------------------------------------------------------------------------------------------------------------------------------------

parameter value did not match expected type java.time.localdatetime (n/a)

https://www.titanwolf.org/Network/q/5c86eca8-0d90-4ec9-b3ec-a8012a4c4233/y
https://stackoverflow.com/questions/52662709/parameter-value-2018-04-08t110244-did-not-match-expected-type-java-util-dat
https://stackoverflow.com/questions/65193840/parameter-value-2020-12-08t0735-did-not-match-expected-type-java-time-locald
https://javarevisited.blogspot.com/2017/08/how-to-format-parse-dates-with-LocalDateTime-Java-8.html#axzz73I5PR0i8     ***********

https://howtodoinjava.com/java/date-time/java-localdatetime-class/
https://howtodoinjava.com/java/date-time/localdatetime-parse/
https://www.baeldung.com/java-8-date-time-intro
https://www.tabnine.com/code/java/classes/java.time.LocalDateTime   ********
https://www.java67.com/2016/04/how-to-convert-string-to-localdatetime-in-java8-example.html

https://thorben-janssen.com/map-date-time-api-jpa-2-2/
https://thorben-janssen.com/persist-localdate-localdatetime-jpa/
https://medium.com/swlh/spring-boot-and-the-localdate-request-parameter-2c9cdbb085bb        *********
https://vladmihalcea.com/date-timestamp-jpa-hibernate/     --Configure UTC in different ways

https://www.javadevjournal.com/java/java-8-format-localdatetime/
https://www.tabnine.com/code/java/methods/java.time.LocalDateTime/getHour  **********Test Case **************
https://www.logicbig.com/tutorials/java-ee-tutorial/jpa/criteria-api-between-operator.html   *****
https://stackoverflow.com/questions/35881681/java-time-format-datetimeparseexception-text-could-not-be-parsed-at-index-21/35881898

http://www.mastertheboss.com/hibernate-jpa/quickstart-tutorials-hibernate-jpa/using-localdate-and-localdatetime-with-jpa/*******************************

Date :
package main.java.com;

import java.time.LocalDateTime;

public class Test2 {

	public static void main(String[] args) {
		String date = "2017-03-08T12:30:54"; 
		LocalDateTime ldt = LocalDateTime.parse(date);
		LocalDateTime ldt1 = LocalDateTime.parse(date);
		LocalDateTime [] lt = new LocalDateTime[2];
		lt[0] = ldt;
		lt[1] = ldt1;
		
		System.out.println("origional date as string: " + date); 
		System.out.println("generated LocalDateTime: " + ldt);
		
		System.out.println(dateFormatterForLogs(ldt));
		LocalDateTime localdatetime = LocalDateTime.of(ldt.getYear(),ldt.getMonth(),ldt.getDayOfMonth(), ldt.getHour(),ldt.getMinute(),ldt.getSecond());
		System.out.println("generated LocalDateTime1 : " + localdatetime);
	}

	private static String dateFormatterForLogs(LocalDateTime dateTime) {
		  String dateString = "[";
		  dateString += dateTime.getDayOfMonth() + "--";
		  dateString += dateTime.getMonthValue() + "--";
		  dateString += dateTime.getYear() + "--";
		  dateString += dateTime.getHour() + ":";
		  dateString += dateTime.getMinute() + ":";
		  dateString += dateTime.getSecond();
		  dateString += "] ";
		  return dateString;
		}

}






https://reflectoring.io/spring-data-specifications/ - *************  Specifications are inspired by the Domain-Driven Design “Specification” pattern
https://medium.com/fleetx-engineering/searching-and-filtering-spring-data-jpa-specification-way-e22bc055229a
https://www.logicbig.com/tutorials/spring-framework/spring-data/specifications.html
https://www.appsdeveloperblog.com/specification-predicate-advance-search-and-filtering-in-jpa/  **************
https://www.netsurfingzone.com/jpa/jpa-criteriabuilder-example/
https://www.programcreek.com/java-api-examples/?class=javax.persistence.criteria.CriteriaBuilder&method=like
https://www.tabnine.com/code/java/methods/javax.persistence.criteria.CriteriaQuery/getRestriction
https://kreepcode.com/spring-data-specification/ ***************************************************** All Example


https://www.callicoder.com/hibernate-spring-boot-jpa-one-to-many-mapping-example/
https://hellokoding.com/jpa-one-to-many-relationship-mapping-example-with-spring-boot-maven-and-mysql/
https://hellokoding.com/mapping-jpa-hibernate-entity-and-dto-with-mapstruct/
https://hellokoding.com/jpa-and-hibernate-one-to-many-unidirectional-spring-boot/

https://medium.com/@a.adendrata/converting-dto-and-entity-c24cba9cef4  -- Time examples

https://github.com/VictoriaAmazonka/stackabuse_dto/blob/master/src/main/java/com/stackabuse/dtoexample/controller/MapController.java
https://stackabuse.com/data-transfer-object-pattern-in-java-implementation-and-mapping
https://www.youtube.com/watch?v=N3uAMuC-bxo  DTO to Entity Video good Example
https://stackabuse.com/guide-to-mapstruct-in-java-advanced-mapping-library               *************
			https://github.com/TaimoorChoudhary/mapstruct
				https://github.com/VictoriaAmazonka/stackabuse_dto
https://www.programmersought.com/article/20453502320/
https://www.amitph.com/spring-entity-to-dto/         -- Junit test Case
------------------------------------------------------------------------------------------------------------------------------------------------------


https://thorben-janssen.com/how-to-join-unrelated-entities/
https://medium.com/@techkarmo/spring-data-jpa-join-with-unrelated-entities-with-help-of-jpql-in-spring-boot-application-c358e11512bd
https://www.programmersought.com/article/7600921460/
https://www.codeproject.com/Questions/5255697/Right-approach-for-aggregating-data-from-multiple
https://roytuts.com/spring-boot-data-jpa-left-right-inner-and-cross-join-examples/

Merge Example
https://onlyfullstack.blogspot.com/2019/02/setting-up-sonar-server-locally.html
https://onlyfullstack.blogspot.com/2019/02/integrate-jacoco-plugin-with-sonar-and-maven.html  next....
https://www.onlyfullstack.com/advance-collectors-in-java-8/ ****************

https://javaconceptoftheday.com/solving-real-time-queries-using-java-8-features-employee-management-system/  ********
https://javaconceptoftheday.com/collections-and-streams-in-java/

https://asbnotebook.com/spring-data-jpa-crud-example/
https://github.com/asbnotebook/spring-boot
https://asbnotebook.com/jpa-many-to-many-example-spring-boot/
https://roytuts.com/spring-boot-data-jpa-left-right-inner-and-cross-join-examples/



   @GetMapping("/user/all")
    public List<UserDTO> getUsers() {
    	List<User> user =  userRepository.findAll();
    	List<UserDTO> userDto = new ArrayList();
    	for (User userq : user) {

    		UserDTO userDTO = new UserDTO();
    		userDTO.setEmail(userq.getEmail());
    		userDTO.setFirstName(userq.getFirstName());
    		userDTO.setLastName(userq.getLastName());
    		userDTO.setMobile(userq.getMobile());
    		userDTO.setRoles(userq.getRoles().stream().map(a -> a.getPermission()).collect(Collectors.joining(",", "", "")));

    		//    		String addressID = userq.getRoles().stream().map(a -> a.getPermission()).collect(Collectors.joining(",", "[", "]")));
    		userDto.add(userDTO);

    	}


    	/*
    	 * List<UserDTO> newList = user.stream() .map(f -> new UserDTO(f.getUserId(),
    	 * f.getFirstName() , f.getLastName(), f.getMobile(), f.getEmail(),
    	 * 
    	 * f.getRoles().stream() .map(a -> a.permission)
    	 * .collect(Collectors.joining(","))) .collect(Collectors.toList();
    	 */
    	return userDto;

    	/*If you wanna create new list, use Stream.map method:
https://stackoverflow.com/questions/38496455/modify-property-value-of-the-objects-in-list-using-java-8-streams/38497684
    		List<Fruit> newList = fruits.stream()
    		    .map(f -> new Fruit(f.getId(), f.getName() + "s", f.getCountry()))
    		    .collect(Collectors.toList())*/
    }
    
    
    import java.util.Random;

public class JavaMainTest {
public static void main(String[] args) {
	/*
	 * int leftLimit = 97; // letter 'a' int rightLimit = 122; // letter 'z' int
	 * targetStringLength = 8; Random random = new Random();
	 * 
	 * String generatedString = random.ints(leftLimit, rightLimit + 1)
	 * .limit(targetStringLength) .collect(StringBuilder::new,
	 * StringBuilder::appendCodePoint, StringBuilder::append) .toString();
	 * 
	 * System.out.println("generatedString  : " + generatedString);
	 */
    
    
    int leftLimit = 48; // numeral '0'
    int rightLimit = 122; // letter 'z'
    int targetStringLength = 8;
    Random random = new Random();

    String generatedString = random.ints(leftLimit, rightLimit + 1)
      .filter(i -> (i <= 57 || i >= 65) && (i <= 90 || i >= 97))
      .limit(targetStringLength)
      .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
      .toString();

    System.out.println(generatedString);
}
}


_____________________________________________________________________________________________________________________________________________

https://reflectoring.io/spring-data-specifications/ - *************  Specifications are inspired by the Domain-Driven Design “Specification” pattern
https://medium.com/fleetx-engineering/searching-and-filtering-spring-data-jpa-specification-way-e22bc055229a
https://www.logicbig.com/tutorials/spring-framework/spring-data/specifications.html
https://www.appsdeveloperblog.com/specification-predicate-advance-search-and-filtering-in-jpa/  **************
https://www.netsurfingzone.com/jpa/jpa-criteriabuilder-example/
https://www.programcreek.com/java-api-examples/?class=javax.persistence.criteria.CriteriaBuilder&method=like
https://www.tabnine.com/code/java/methods/javax.persistence.criteria.CriteriaQuery/getRestriction
https://kreepcode.com/spring-data-specification/ ***************************************************** All Example



# Dynamic Queries with Spring Data JPA Specifications

For step-by-step instructions, please check out [blog post](https://attacomsian.com/blog/spring-data-jpa-specifications).


package com.attacomsian.jpa;

import com.attacomsian.jpa.domains.Movie;
import com.attacomsian.jpa.repositories.MovieRepository;
import com.attacomsian.jpa.repositories.specs.MovieSpecification;
import com.attacomsian.jpa.repositories.specs.SearchCriteria;
import com.attacomsian.jpa.repositories.specs.SearchOperation;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.List;

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Bean
    public CommandLineRunner specificationsDemo(MovieRepository movieRepository) {
        return args -> {
            String time = "2019-03-27T10:15:30";
            LocalDateTime localTimeObj = LocalDateTime.parse(time);
            DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            // create new movies
            movieRepository.saveAll(Arrays.asList(


                    new Movie("Troy2", "Drama", 7.2, 196, 2004,"2021-07-27 7:07:32",  localTimeObj),
                    new Movie("The Godfather2", "Crime", 9.2, 178, 1972,"2020-07-27 7:07:32",  localTimeObj.minusYears(1)),
                    new Movie("Invictus2", "Sport", 7.3, 135, 2009,"2019-07-27 7:07:32",  localTimeObj.minusYears(2)),
                    new Movie("Black Panther2", "Action", 7.3, 135, 2018,"2018-07-27 7:07:32",  localTimeObj.minusYears(3)),
                    new Movie("Joker2", "Drama", 8.9, 122, 2018,"2017-07-27 7:07:32",  localTimeObj.minusYears(4)),
                    new Movie("Iron Man2", "Action", 8.9, 126, 2008,"2016-07-27 7:07:32",  localTimeObj.minusYears(5)),


                    new Movie("Troy", "Drama", 7.2, 196, 2004,"2021-07-27T07:07:32",  localTimeObj),
                    new Movie("The Godfather", "Crime", 9.2, 178, 1972,"2020-07-27T07:07:32",  localTimeObj.minusYears(1)),
                    new Movie("Invictus", "Sport", 7.3, 135, 2009,"2019-07-27T07:07:32",  localTimeObj.minusYears(2)),
                    new Movie("Black Panther", "Action", 7.3, 135, 2018,"2018-07-27T07:07:32",  localTimeObj.minusYears(3)),
                    new Movie("Joker", "Drama", 8.9, 122, 2018,"2017-07-27T07:07:32",  localTimeObj.minusYears(4)),
                    new Movie("Iron Man", "Action", 8.9, 126, 2008,"2016-07-27T07:07:32",  localTimeObj.minusYears(5)),

            new Movie("Troy", "Drama1", 7.2, 196, 2004,"2021-07-27T07:07:32",  localTimeObj.minusYears(6)),
                    new Movie("The Godfather1", "Crime", 9.2, 178, 1972,"2021-07-27T07:08:32",  localTimeObj.minusYears(7)),
                    new Movie("Invictus1", "Sport", 7.3, 135, 2009,"2021-07-27T07:09:32",  localTimeObj.minusYears(8)),
                    new Movie("Black Panther1", "Action", 7.3, 135, 2018,"2021-07-27T07:10:32",  localTimeObj.minusYears(9)),
                    new Movie("Joker1", "Drama", 8.9, 122, 2018,"2021-07-27T07:11:32",  localTimeObj.minusYears(10)),
                    new Movie("Iron Man1", "Action", 8.9, 126, 2008,"2021-07-27T07:12:32",  localTimeObj.minusYears(11))
            ));

            /*// search movies by `genre`
            MovieSpecification msGenre = new MovieSpecification();
            msGenre.add(new SearchCriteria("genre", "Action", SearchOperation.EQUAL));
            List<Movie> msGenreList = movieRepository.findAll(msGenre);
            msGenreList.forEach(System.out::println);
            System.out.println("______________________________________________________________________________");
            // search movies by `title` and `rating` > 7
            MovieSpecification msTitleRating = new MovieSpecification();
            msTitleRating.add(new SearchCriteria("title", "black", SearchOperation.MATCH));
            msTitleRating.add(new SearchCriteria("rating", 7, SearchOperation.GREATER_THAN));
            List<Movie> msTitleRatingList = movieRepository.findAll(msTitleRating);
            msTitleRatingList.forEach(System.out::println);
            System.out.println("______________________________________________________________________________");
            // search movies by release year < 2010 and rating > 8
            MovieSpecification msYearRating = new MovieSpecification();
            msYearRating.add(new SearchCriteria("releaseYear", 2010, SearchOperation.LESS_THAN));
            msYearRating.add(new SearchCriteria("rating", 8, SearchOperation.GREATER_THAN));
            List<Movie> msYearRatingList = movieRepository.findAll(msYearRating);
            msYearRatingList.forEach(System.out::println);
            System.out.println("______________________________________________________________________________");
            // search movies by watch time >= 150 and sort by `title`
            MovieSpecification msWatchTime = new MovieSpecification();
            msWatchTime.add(new SearchCriteria("watchTime", 150, SearchOperation.GREATER_THAN_EQUAL));
            List<Movie> msWatchTimeList = movieRepository.findAll(msWatchTime, Sort.by("title"));
            msWatchTimeList.forEach(System.out::println);*/

          /*  System.out.println("______________________________________________________________________________");
            // search movies by watch time >= 150 and sort by `title`
            MovieSpecification msDateTime = new MovieSpecification();
            msDateTime.add(new SearchCriteria("startDate", "2021-07-27T07:07:32", SearchOperation.GREATER_THAN_EQUAL));
            List<Movie> msDateTimeList = movieRepository.findAll(msDateTime);
            msDateTimeList.forEach(System.out::println);

            System.out.println("______________________________________________________________________________");
            // search movies by watch time >= 150 and sort by `title`
            MovieSpecification msDateTime1 = new MovieSpecification();
            msDateTime1.add(new SearchCriteria("startDate", "2021-07-27T07:07:32", SearchOperation.LESS_THAN_EQUAL));
             movieRepository.findAll(msDateTime1).forEach(System.out::println);
            System.out.println("______________________________________________________________________________");

            // search movies by watch time >= 150 and sort by `title`
            MovieSpecification msDateTime2 = new MovieSpecification();
            msDateTime2.add(new SearchCriteria("startDate", "2021-07-27T07:07:32", SearchOperation.GREATER_THAN));
            movieRepository.findAll(msDateTime2).forEach(System.out::println);
            System.out.println("______________________________________________________________________________");

            // search movies by watch time >= 150 and sort by `title`
            MovieSpecification msDateTime3 = new MovieSpecification();
            msDateTime3.add(new SearchCriteria("startDate", "2021-07-27T07:07:32", SearchOperation.LESS_THAN));
            movieRepository.findAll(msDateTime3).forEach(System.out::println);
            System.out.println("______________________________________________________________________________");
            // search movies by watch time >= 150 and sort by `title`
            MovieSpecification msDateTime4 = new MovieSpecification();
            msDateTime4.add(new SearchCriteria("startDate", "2021-07-27T07:07:32", SearchOperation.EQUAL));
            movieRepository.findAll(msDateTime4).forEach(System.out::println);*/
           /* System.out.println("______________________________________________________________________________");

           // search movies by watch time >= 150 and sort by `title`
            MovieSpecification msDateTime5 = new MovieSpecification();
            msDateTime5.add(new SearchCriteria("startDate", "2021-07-27T07:12:32", "2019-07-27T07:07:32", SearchOperation.BETWEEN));
            movieRepository.findAll(msDateTime5).forEach(System.out::println);
            List<Movie> msDateTimeList = movieRepository.findAll(msDateTime5);
            msDateTimeList.forEach(System.out::println);
            System.out.println("______________________________________________________________________________");*/
           /* System.out.println("______________________________________Start________________________________________");
            // search movies by watch time >= 150 and sort by `title`
            MovieSpecification msDateTime7 = new MovieSpecification();
           // msDateTime7.add(new SearchCriteria("startDate", "2017-07-27 7:07:32", SearchOperation.LESS_THAN_EQUAL));
            msDateTime7.add(new SearchCriteria("startDate", "2021-07-27 7:07:32", SearchOperation.EQUAL));
            List<Movie> msDateTimeList7 = movieRepository.findAll(msDateTime7);
            msDateTimeList7.forEach(System.out::println);
            System.out.println("___________________________________End___________________________________________");
*/

            // search movies by watch time >= 150 and sort by `title`
            MovieSpecification msDateTime8 = new MovieSpecification();
            msDateTime8.add(new SearchCriteria("releaseYear", 2009, SearchOperation.LESS_THAN_EQUAL));
            msDateTime8.add(new SearchCriteria("releaseYear", 2004, SearchOperation.GREATER_THAN_EQUAL));
            List<Movie> msDateTimeList8 = movieRepository.findAll(msDateTime8);
            msDateTimeList8.forEach(System.out::println);
             System.out.println("___________________________________End___________________________________________");


            System.out.println("___________________________________Start___________________________________________");

            MovieSpecification msDateTime9 = new MovieSpecification();
            msDateTime9.add(new SearchCriteria("localDateTime", localTimeObj,  localTimeObj.minusYears(6), SearchOperation.BETWEEN));
//            msDateTime9.add(new SearchCriteria("localDateTime", LocalDateTime.now(), SearchOperation.LESS_THAN_EQUAL));
            List<Movie> msDateTimeList9= movieRepository.findAll(msDateTime9);
            msDateTimeList9.forEach(System.out::println);
            System.out.println("___________________________________End___________________________________________");

/*            System.out.println("______________________________________________________________________________");
            // search movies by title <> 'white' and paginate results
            MovieSpecification msTitle = new MovieSpecification();
            msTitle.add(new SearchCriteria("title", "white", SearchOperation.NOT_EQUAL));
            Pageable pageable = PageRequest.of(0, 3, Sort.by("releaseYear").descending());
            Page<Movie> msTitleList = movieRepository.findAll(msTitle, pageable);

            msTitleList.forEach(System.out::println);*/
        };
    }
}


---------------

public enum SearchOperation {
    GREATER_THAN,
    LESS_THAN,
    GREATER_THAN_EQUAL,
    LESS_THAN_EQUAL,
    NOT_EQUAL,
    EQUAL,
    MATCH,
    MATCH_START,
    MATCH_END,
    IN,
    NOT_IN,
    BETWEEN
}

---------------------
public class SearchCriteria {
    private String key;
    private Object value;



    private Object value2;
    private SearchOperation operation;

    public SearchCriteria() {
    }

    public SearchCriteria(String key, Object value, SearchOperation operation) {
        this.key = key;
        this.value = value;
        this.operation = operation;

    }

    public SearchCriteria(String key, Object value, Object value2,SearchOperation operation) {
        this.key = key;
        this.value = value;
        this.operation = operation;
        this.value2 = value2;
    }

    // getters and setters, equals(), toString(), ... (omitted for brevity)

    public String getKey() {
        return key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public SearchOperation getOperation() {
        return operation;
    }

    public Object getValue2() {
        return value2;
    }

    public void setValue2(Object value2) {
        this.value2 = value2;
    }

    public void setOperation(SearchOperation operation) {
        this.operation = operation;
    }

    @Override
    public String toString() {
        return "SearchCriteria{" +
                "key='" + key + '\'' +
                ", value=" + value +
                ", value2=" + value2 +
                ", operation=" + operation +
                '}';
    }
}

------------------------------------------------

 else if (criteria.getOperation().equals(SearchOperation.BETWEEN)) {
                predicates.add(builder.between(root.get(criteria.getKey()), criteria.getValue().toString(), criteria.getValue().toString()));
            }
	    
__________________________________________________________________________________________________________________________________

package com.logicbig.example;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Join;
import javax.persistence.criteria.Root;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class ExampleMain2 {
    private static EntityManagerFactory entityManagerFactory =
            Persistence.createEntityManagerFactory("example-unit");

    public static void main(String[] args) {
        try {
            persistEmployees();
//            findEmployeeBySalaryRange();
//            findEmployeeBySalaryRange2();
            findEmployeeByJoinDate();
        } finally {
            entityManagerFactory.close();
        }
    }

	/*
	 * private static void findEmployeeBySalaryRange() {
	 * System.out.println("-- Employee with salary BETWEEN 2000 and 4000 --");
	 * EntityManager em = entityManagerFactory.createEntityManager();
	 * CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();
	 * CriteriaQuery<Employee> query = criteriaBuilder.createQuery(Employee.class);
	 * Root<Employee> employee = query.from(Employee.class); query.select(employee)
	 * // .where(criteriaBuilder.between(employee.get(Employee_.salary), 2000L,
	 * 4000L)); .where(criteriaBuilder.between(employee.get("salary"), 2000L,
	 * 4000L)); List<Employee> resultList = em.createQuery(query).getResultList();
	 * resultList.forEach(System.out::println); em.close(); }
	 */

	/*
	 * private static void findEmployeeBySalaryRange2() { System.out.
	 * println("-- Employee with salary BETWEEN supervisor's salary and 4000 --");
	 * EntityManager em = entityManagerFactory.createEntityManager();
	 * CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();
	 * CriteriaQuery<Employee> query = criteriaBuilder.createQuery(Employee.class);
	 * Root<Employee> employee = query.from(Employee.class); Join<Employee,
	 * Employee> supervisor = employee.join(Employee_.supervisor);
	 * query.select(employee)
	 * .where(criteriaBuilder.between(employee.get(Employee_.salary),
	 * supervisor.get(Employee_.salary), criteriaBuilder.literal(4000L)));
	 * List<Employee> resultList = em.createQuery(query).getResultList();
	 * resultList.forEach(System.out::println); em.close(); }
	 */

    private static void findEmployeeByJoinDate() {
    	
    	String time = "2019-03-27T10:15:30";
        LocalDateTime localTimeObj = LocalDateTime.parse(time);
        DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
//        LocalDateTime localTimeObj = LocalDateTime.parse(time, formatter1);
        
        System.out.println("-- Employee with join date BETWEEN '1990-01-01' and '2010-05-01' --");
        EntityManager em = entityManagerFactory.createEntityManager();
        CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();
        CriteriaQuery<Employee> query = criteriaBuilder.createQuery(Employee.class);
        Root<Employee> employee = query.from(Employee.class);
        System.out.println("LocalDateTime.now().minusYears(6)"+LocalDateTime.now().minusYears(4));
        query.select(employee)
//             .where(criteriaBuilder.between(employee.get(Employee_.joinDate),
        
				/*
				 * .where(criteriaBuilder.between(employee.get("localDateTime"),
				 * LocalDateTime.now().minusYears(6), //LocalDateTime.of(2019, 03,27, 0, 0, 0)
				 * LocalDateTime.of(2019, 03,27, 0, 0, 0) )
				 */
        		
        		.where(criteriaBuilder.lessThan(employee.get("localDateTime"),
                		LocalDateTime.of(2019, 03,27, 0, 0, 0)
                	)

//             .orderBy(criteriaBuilder.desc(employee.get(Employee_.joinDate)));
        );
        
        List<Employee> resultList = em.createQuery(query).getResultList();
        resultList.forEach(System.out::println);
        em.close();
    }
    
    

    private static Timestamp localToTimeStamp(LocalDate date) {
        return Timestamp.from(date.atStartOfDay().toInstant(ZoneOffset.UTC));
    }

    public static void persistEmployees() {
    	
    	String time = "2019-03-27 10:15:30";
       // LocalDateTime localTimeObj = LocalDateTime.parse(time);
        DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        LocalDateTime localTimeObj = LocalDateTime.parse(time, formatter1);
        Employee employee1 = Employee.create("Diana", 3000, LocalDate.of(1999, 11, 15), "2020-07-27 7:07:32", localTimeObj.minusYears(4));
        Employee employee2 = Employee.create("Rose", 4000, LocalDate.of(2011, 5, 1), "07/27/2020",  localTimeObj.minusYears(1));
        Employee employee3 = Employee.create("Denise", 1500, LocalDate.of(2006, 1, 10), "07/27/2019",  localTimeObj.minusYears(2));
        Employee employee4 = Employee.create("Mike", 2000, LocalDate.of(2015, 8, 20), "07/27/2018",  localTimeObj.minusYears(3));
        employee1.setSupervisor(employee4);
        employee2.setSupervisor(employee1);
        employee3.setSupervisor(employee1);
        employee4.setSupervisor(null);


        EntityManager em = entityManagerFactory.createEntityManager();
        em.getTransaction().begin();
        em.persist(employee1);
        em.persist(employee2);
        em.persist(employee3);
        em.persist(employee4);
        em.getTransaction().commit();
        em.close();
        System.out.println("-- employee persisted --");
        System.out.println(employee1);
        System.out.println(employee2);
        System.out.println(employee3);
        System.out.println(employee4);
    }
}

INFO: HHH000206: hibernate.properties not found
Aug 13, 2021 9:33:09 AM org.hibernate.annotations.common.reflection.java.JavaReflectionManager <clinit>
INFO: HCANN000001: Hibernate Commons Annotations {5.0.4.Final}
Aug 13, 2021 9:33:09 AM org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl configure
WARN: HHH10001002: Using Hibernate built-in connection pool (not for production use!)
Aug 13, 2021 9:33:09 AM org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator
INFO: HHH10001005: using driver [org.h2.Driver] at URL [jdbc:h2:mem:test;DB_CLOSE_DELAY=-1]
Aug 13, 2021 9:33:09 AM org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator
INFO: HHH10001001: Connection properties: {}
Aug 13, 2021 9:33:09 AM org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl buildCreator
INFO: HHH10001003: Autocommit mode: false
Aug 13, 2021 9:33:09 AM org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl$PooledConnections <init>
INFO: HHH000115: Hibernate connection pool size: 20 (min=1)
Aug 13, 2021 9:33:09 AM org.hibernate.dialect.Dialect <init>
INFO: HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
Aug 13, 2021 9:33:10 AM org.hibernate.resource.transaction.backend.jdbc.internal.DdlTransactionIsolatorNonJtaImpl getIsolatedConnection
INFO: HHH10001501: Connection obtained from JdbcConnectionAccess [org.hibernate.engine.jdbc.env.internal.JdbcEnvironmentInitiator$ConnectionProviderJdbcConnectionAccess@b606cb6] for (non-JTA) DDL execution was not in auto-commit mode; the Connection 'local transaction' will be committed and the Connection will be set into auto-commit mode.
Aug 13, 2021 9:33:10 AM org.hibernate.tool.schema.internal.SchemaCreatorImpl applyImportSources
INFO: HHH000476: Executing import script 'org.hibernate.tool.schema.internal.exec.ScriptSourceInputNonExistentImpl@e5cbff2'
-- employee persisted --
Employee{id=1, name='Diana', joinDate=1999-11-15 05:30:00.0, salary=3000, startDate=2020-07-27 7:07:32, localDateTime=2015-03-27T10:15:30, supervisor=Mike}
Employee{id=2, name='Rose', joinDate=2011-05-01 05:30:00.0, salary=4000, startDate=07/27/2020, localDateTime=2018-03-27T10:15:30, supervisor=Diana}
Employee{id=3, name='Denise', joinDate=2006-01-10 05:30:00.0, salary=1500, startDate=07/27/2019, localDateTime=2017-03-27T10:15:30, supervisor=Diana}
Employee{id=4, name='Mike', joinDate=2015-08-20 05:30:00.0, salary=2000, startDate=07/27/2018, localDateTime=2016-03-27T10:15:30, supervisor=null}
-- Employee with join date BETWEEN '1990-01-01' and '2010-05-01' --
LocalDateTime.now().minusYears(6)2017-08-13T09:33:11.123436400
Aug 13, 2021 9:33:11 AM org.hibernate.hql.internal.QueryTranslatorFactoryInitiator initiateService
INFO: HHH000397: Using ASTQueryTranslatorFactory
Employee{id=1, name='Diana', joinDate=1999-11-15 05:30:00.0, salary=3000, startDate=2020-07-27 7:07:32, localDateTime=2015-03-27T10:15:30, supervisor=Mike}
Employee{id=2, name='Rose', joinDate=2011-05-01 05:30:00.0, salary=4000, startDate=07/27/2020, localDateTime=2018-03-27T10:15:30, supervisor=Diana}
Employee{id=3, name='Denise', joinDate=2006-01-10 05:30:00.0, salary=1500, startDate=07/27/2019, localDateTime=2017-03-27T10:15:30, supervisor=Diana}
Employee{id=4, name='Mike', joinDate=2015-08-20 05:30:00.0, salary=2000, startDate=07/27/2018, localDateTime=2016-03-27T10:15:30, supervisor=null}
Aug 13, 2021 9:33:11 AM org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl stop
INFO: HHH10001008: Cleaning up connection pool [jdbc:h2:mem:test;DB_CLOSE_DELAY=-1]

package com.logicbig.example;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.OneToOne;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;

@Entity
public class Employee {
    @Id
    @GeneratedValue
    private long id;
    private String name;
    private Timestamp joinDate;
    private long salary;
    
    private String startDate;
    private LocalDateTime localDateTime;
    
    @OneToOne
    private Employee supervisor;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Timestamp getJoinDate() {
        return joinDate;
    }

    public void setJoinDate(Timestamp joinDate) {
        this.joinDate = joinDate;
    }

    public long getSalary() {
        return salary;
    }

    public void setSalary(long salary) {
        this.salary = salary;
    }

    public Employee getSupervisor() {
        return supervisor;
    }

    public void setSupervisor(Employee supervisor) {
        this.supervisor = supervisor;
    }

    public static Employee create(String name, int salary, LocalDate joinDate, String startDate, LocalDateTime localDateTime) {
		/*
		 * String time = "2019-03-27T10:15:30"; LocalDateTime localTimeObj =
		 * LocalDateTime.parse(time); DateTimeFormatter formatter1 =
		 * DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		 */
        Employee employee = new Employee();
        employee.setName(name);
        employee.setSalary(salary);
        employee.setJoinDate(Timestamp.from(joinDate.atStartOfDay().toInstant(ZoneOffset.UTC)));
        employee.setStartDate(startDate);
        employee.setLocalDateTime(localDateTime);
        return employee;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", joinDate=" + joinDate +
                ", salary=" + salary +
                ", startDate=" + startDate +
                ", localDateTime=" + localDateTime +
                ", supervisor=" + (supervisor == null ? "null" : supervisor.name) +
                '}';
    }

	public String getStartDate() {
		return startDate;
	}

	public void setStartDate(String startDate) {
		this.startDate = startDate;
	}

	public LocalDateTime getLocalDateTime() {
		return localDateTime;
	}

	public void setLocalDateTime(LocalDateTime localDateTime) {
		this.localDateTime = localDateTime;
	}
}


package com.logicbig.example;

import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Join;
import javax.persistence.criteria.Root;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class ExampleMain {
    private static EntityManagerFactory entityManagerFactory =
            Persistence.createEntityManagerFactory("example-unit");

    public static void main(String[] args) {
        try {
            persistEmployees();
//            findEmployeeBySalaryRange();
//            findEmployeeBySalaryRange2();
            findEmployeeByJoinDate();
        } finally {
            entityManagerFactory.close();
        }
    }

	/*
	 * private static void findEmployeeBySalaryRange() {
	 * System.out.println("-- Employee with salary BETWEEN 2000 and 4000 --");
	 * EntityManager em = entityManagerFactory.createEntityManager();
	 * CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();
	 * CriteriaQuery<Employee> query = criteriaBuilder.createQuery(Employee.class);
	 * Root<Employee> employee = query.from(Employee.class); query.select(employee)
	 * // .where(criteriaBuilder.between(employee.get(Employee_.salary), 2000L,
	 * 4000L)); .where(criteriaBuilder.between(employee.get("salary"), 2000L,
	 * 4000L)); List<Employee> resultList = em.createQuery(query).getResultList();
	 * resultList.forEach(System.out::println); em.close(); }
	 */

	/*
	 * private static void findEmployeeBySalaryRange2() { System.out.
	 * println("-- Employee with salary BETWEEN supervisor's salary and 4000 --");
	 * EntityManager em = entityManagerFactory.createEntityManager();
	 * CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();
	 * CriteriaQuery<Employee> query = criteriaBuilder.createQuery(Employee.class);
	 * Root<Employee> employee = query.from(Employee.class); Join<Employee,
	 * Employee> supervisor = employee.join(Employee_.supervisor);
	 * query.select(employee)
	 * .where(criteriaBuilder.between(employee.get(Employee_.salary),
	 * supervisor.get(Employee_.salary), criteriaBuilder.literal(4000L)));
	 * List<Employee> resultList = em.createQuery(query).getResultList();
	 * resultList.forEach(System.out::println); em.close(); }
	 */

    private static void findEmployeeByJoinDate() {
    	
    	String time = "2019-03-27T10:15:30";
        LocalDateTime localTimeObj = LocalDateTime.parse(time);
        DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        
        System.out.println("-- Employee with join date BETWEEN '1990-01-01' and '2010-05-01' --");
        EntityManager em = entityManagerFactory.createEntityManager();
        CriteriaBuilder criteriaBuilder = em.getCriteriaBuilder();
        CriteriaQuery<Employee> query = criteriaBuilder.createQuery(Employee.class);
        Root<Employee> employee = query.from(Employee.class);
        query.select(employee)
//             .where(criteriaBuilder.between(employee.get(Employee_.joinDate),
        .where(criteriaBuilder.between(employee.get("joinDate"),
        			
			localToTimeStamp(LocalDate.of(1990, 01, 01)),
			localToTimeStamp(LocalDate.of(2010, 05, 01)))
        		
        	)
						 
        			

//             .orderBy(criteriaBuilder.desc(employee.get(Employee_.joinDate)));
        .orderBy(criteriaBuilder.desc(employee.get("joinDate")));
        
        List<Employee> resultList = em.createQuery(query).getResultList();
        resultList.forEach(System.out::println);
        em.close();
    }
    
    

    private static Timestamp localToTimeStamp(LocalDate date) {
        return Timestamp.from(date.atStartOfDay().toInstant(ZoneOffset.UTC));
    }

    public static void persistEmployees() {
    	
    	String time = "2019-03-27T10:15:30";
        LocalDateTime localTimeObj = LocalDateTime.parse(time);
        DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        
        Employee employee1 = Employee.create("Diana", 3000, LocalDate.of(1999, 11, 15), "2020-07-27 7:07:32", localTimeObj.minusYears(4));
        Employee employee2 = Employee.create("Rose", 4000, LocalDate.of(2011, 5, 1), "07/27/2020",  localTimeObj.minusYears(1));
        Employee employee3 = Employee.create("Denise", 1500, LocalDate.of(2006, 1, 10), "07/27/2019",  localTimeObj.minusYears(2));
        Employee employee4 = Employee.create("Mike", 2000, LocalDate.of(2015, 8, 20), "07/27/2018",  localTimeObj.minusYears(3));
        employee1.setSupervisor(employee4);
        employee2.setSupervisor(employee1);
        employee3.setSupervisor(employee1);
        employee4.setSupervisor(null);


        EntityManager em = entityManagerFactory.createEntityManager();
        em.getTransaction().begin();
        em.persist(employee1);
        em.persist(employee2);
        em.persist(employee3);
        em.persist(employee4);
        em.getTransaction().commit();
        em.close();
        System.out.println("-- employee persisted --");
        System.out.println(employee1);
        System.out.println(employee2);
        System.out.println(employee3);
        System.out.println(employee4);
    }
}



-----------------------------------------------------------------------------------------------

https://docs.gradle.org/current/userguide/upgrading_version_6.html

https://www.jetbrains.com/idea/guide/tutorials/working-with-gradle/shortcuts-used/


https://www.jetbrains.com/idea/guide/tutorials/working-with-gradle/

https://www.jetbrains.com/help/idea/gradle-settings.html
https://www.jetbrains.com/idea/guide/tutorials/working-with-gradle/syncing-and-reloading/
https://www.jetbrains.com/idea/guide/tutorials/working-with-gradle/gradle-settings/

https://www.jetbrains.com/idea/guide/tutorials/working-with-gradle/gradle-wrapper/  ******
		If you update the gradle-wrapper.properties file to have a different version number, IntelliJ IDEA will detect the changes and asks us to reload these changes. 
		The IDE will download this new version of Gradle, and then rebuild the project using it.
		
https://intellij-support.jetbrains.com/hc/en-us/community/posts/360000029630-Please-update-Gradle-plugin-for-latest-  ****
		For those who land on this page because they are looking for how to update Gradle in IntelliJ.
This page explains that relatively well:
https://docs.gradle.org/current/userguide/gradle_wrapper.html#sec:upgrading_wrapper

With me (Windows) it was:
gradlew.bat wrapper --gradle-version 6.6.1


https://docs.gradle.org/current/userguide/gradle_wrapper.html#sec:upgrading_wrapper

https://docs.gradle.org/7.0/userguide/upgrading_version_6.html
https://gradle.org/whats-new/gradle-7/

-------------------------------------------------------------------------------------------------------------------------------
	   
